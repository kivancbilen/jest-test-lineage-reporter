# Mutation Testing Debug Mode

This guide explains how to use the debug mode for mutation testing to troubleshoot issues and inspect generated mutations.

## Problem

The mutation tester is experiencing Jest exit code 7 errors when running actual tests on mutations. This makes it difficult to debug what's happening with the mutations themselves.

## Solution: Debug Mode

Debug mode creates mutation files as separate files instead of overwriting the originals and running tests. This allows you to:

1. **Inspect the actual mutations** generated by the mutation tester
2. **Manually run tests** on specific mutations to debug issues
3. **Avoid Jest module loading conflicts** that cause exit code 7 errors
4. **Understand what mutations are being applied** to your code

## How to Enable Debug Mode

### Option 1: Configuration File

Create or modify your Jest configuration:

```javascript
// jest.config.js
module.exports = {
  reporters: [
    'default',
    [
      './src/TestCoverageReporter.js',
      {
        enableMutationTesting: true,
        debugMutations: true,                    // Enable debug mode
        debugMutationDir: './mutations-debug',  // Directory for debug files
        // ... other options
      }
    ]
  ]
};
```

### Option 2: Environment Variable

```bash
# Set debug mode via environment
JEST_LINEAGE_DEBUG_MUTATIONS=true npm test
```

## What Debug Mode Does

1. **Creates separate mutation files** instead of overwriting originals
2. **Generates metadata files** with mutation details
3. **Skips test execution** to avoid Jest conflicts
4. **Preserves all files** for manual inspection

## Debug Output Structure

When you run mutation testing in debug mode, it creates:

```
mutations-debug/
├── calculator_L15_arithmetic.mutation.ts     # Mutated code
├── calculator_L15_arithmetic.metadata.json   # Mutation details
├── calculator_L23_comparison.mutation.ts     # Another mutation
├── calculator_L23_comparison.metadata.json   # Its metadata
└── ...
```

### Mutation File Example

```typescript
// calculator_L15_arithmetic.mutation.ts
export function add(a: number, b: number): number {
  return a - b;  // ← Mutation: + changed to -
}
```

### Metadata File Example

```json
{
  "originalFile": "src/calculator.ts",
  "lineNumber": 15,
  "mutationType": "arithmetic",
  "mutationFile": "./mutations-debug/calculator_L15_arithmetic.mutation.ts",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "originalLine": "  return a + b;"
}
```

## Manual Testing Workflow

1. **Run debug mode** to generate mutation files
2. **Inspect mutations** to verify they're correct
3. **Manually test specific mutations**:
   ```bash
   # Copy mutation file over original temporarily
   cp mutations-debug/calculator_L15_arithmetic.mutation.ts src/calculator.ts
   
   # Run specific tests
   npm test -- --testPathPattern=calculator.test.ts
   
   # Restore original
   git checkout src/calculator.ts
   ```

## Debugging Common Issues

### Issue: No mutations generated
- Check that lineage data exists (`.jest-lineage-data.json`)
- Verify file patterns match your source files
- Ensure lines have test coverage

### Issue: Incorrect mutations
- Inspect the `.mutation.ts` files to see actual changes
- Check the metadata files for mutation details
- Verify the mutation logic in `applyMutationDirectly()`

### Issue: Jest exit code 7 in normal mode
- Use debug mode to verify mutations are correct
- Check for module loading conflicts
- Consider running mutations in isolated processes

## Configuration Options

```javascript
{
  debugMutations: false,              // Enable/disable debug mode
  debugMutationDir: './mutations-debug', // Output directory
  mutationTimeout: 5000,              // Timeout per mutation (ignored in debug)
  maxMutationsPerLine: 3,             // Limit mutations for easier debugging
}
```

## Next Steps

After using debug mode to verify mutations are correct:

1. **Fix Jest module loading issues** in normal mode
2. **Implement isolated test execution** to avoid conflicts
3. **Add more mutation types** based on debug findings
4. **Optimize mutation generation** for better coverage

## Example Usage

```bash
# Run with debug mode
JEST_LINEAGE_DEBUG_MUTATIONS=true npm test -- --testPathPattern=calculator.test.ts

# Check generated files
ls -la mutations-debug/

# Inspect a specific mutation
cat mutations-debug/calculator_L15_arithmetic.mutation.ts
cat mutations-debug/calculator_L15_arithmetic.metadata.json
```

This debug mode helps isolate the mutation generation logic from the test execution issues, making it much easier to troubleshoot and improve the mutation testing implementation.
